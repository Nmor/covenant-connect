# Donation Webhook Reference

The Nest donation service exposes webhook endpoints for each supported payment provider. Every endpoint expects a JSON payload and validates the provider-specific signature before reconciling the donation inside a database transaction. A successful reconciliation responds with `{ "status": "updated" }`. Duplicate or stale notifications that do not change any persisted state respond with `{ "status": "ignored" }`.

## Shared behaviour

* **Content type** – send requests as `application/json`. The service computes message signatures against the raw request body, so avoid whitespace or reformatting changes between signing and delivery.
* **Status transitions** – webhook updates only advance a donation through `pending → failed → completed → refunded`. Older states (for example, a `failed` notice that arrives after `completed`) are ignored to keep records consistent.
* **Transaction safety** – reconciliation uses `prisma.$transaction` to atomically compare the existing donation state, merge metadata, and persist any updates. This prevents race conditions when multiple webhook deliveries arrive in quick succession.

## Paystack

* **Endpoint**: `POST /donations/webhooks/paystack`
* **Signature header**: `x-paystack-signature`
* **Secret**: configure `PAYSTACK_WEBHOOK_SECRET`. If omitted, the service falls back to `PAYSTACK_SECRET_KEY`.
* **Algorithm**: HMAC SHA-512 computed over the raw request body.
* **Payload hints**: the handler inspects `data.status`, `data.reference`, and `data.id`. Include those fields so the donation can be located and reconciled.

## Fincra

* **Endpoint**: `POST /donations/webhooks/fincra`
* **Signature header**: `x-fincra-signature`
* **Secret**: configure `FINCRA_WEBHOOK_SECRET`. If omitted, the service falls back to `FINCRA_SECRET_KEY`.
* **Algorithm**: HMAC SHA-256 computed over the raw request body.
* **Payload hints**: the handler reads `status`, `reference`, and `transactionId`. Supply `failureReason` when a payment fails to populate the donation error message.

## Stripe

* **Endpoint**: `POST /donations/webhooks/stripe`
* **Signature header**: `stripe-signature`
* **Secret**: `STRIPE_WEBHOOK_SECRET` (this must be the endpoint secret generated by Stripe).
* **Algorithm**: HMAC SHA-256 using Stripe's signed payload format (`t=timestamp,v1=signature`).
* **Payload hints**: send standard Stripe event payloads (for example `checkout.session.completed`). The service extracts the session `id`, `client_reference_id`, `payment_intent`, and `payment_status` from `data.object`.

## Flutterwave

* **Endpoint**: `POST /donations/webhooks/flutterwave`
* **Signature header**: `verif-hash`
* **Secret**: configure `FLUTTERWAVE_WEBHOOK_SECRET` or `FLUTTERWAVE_SECRET_HASH`. If neither is set, the service falls back to `FLUTTERWAVE_SECRET_KEY` for comparisons.
* **Algorithm**: constant-time comparison against the configured secret hash (Flutterwave does not sign with the request body).
* **Payload hints**: include `status`, `tx_ref`, and `id` fields. The handler also logs `processor_response` for failed payments.

## Testing locally

1. Start the backend (`npm run dev -w apps/backend`).
2. Use a tool such as `curl` or `ngrok` to deliver webhook payloads to the appropriate endpoint.
3. Compute the required signature with the configured secret before sending the request.
4. Inspect the response (`updated` vs `ignored`) and confirm that the donation record reflects the new status in the database.
